//-----------------------------------------------------------------------------
// <auto-generated> 
//   This code was generated by a tool. 
// 
//   Changes to this file may cause incorrect behavior and will be lost if  
//   the code is regenerated.
//
//   Tool: AllJoynCodeGen.exe
//   Version: 1.0.0
//
//   This tool is located in the Windows 10 SDK and the Windows 10 AllJoyn 
//   Visual Studio Extension in the Visual Studio Extension Gallery.  
//
//   The generated code should be packaged in a Windows 10 C++/CX Runtime  
//   Component which can be consumed in any UAP-supported language using 
//   APIs that are available in Windows.Devices.AllJoyn.
//
//   Using AllJoynCodeGen - Invoke the following command with a valid 
//   Introspection XML file:
//     AllJoynCodeGen -i <INPUT XML FILE> -o <OUTPUT DIRECTORY>
// </auto-generated>
//-----------------------------------------------------------------------------
#include "pch.h"

using namespace concurrency;
using namespace Microsoft::WRL;
using namespace Platform;
using namespace Windows::Foundation;
using namespace Windows::Foundation::Collections;
using namespace Windows::Devices::AllJoyn;
using namespace org::allseen::LSF;
namespace org { namespace allseen { namespace LSF {

// Methods
LampStateTransitionLampStateCalledEventArgs::LampStateTransitionLampStateCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ uint64 interface_timestamp,
    _In_ Windows::Foundation::Collections::IMapView<Platform::String^,Platform::Object^>^ interface_newState,
    _In_ uint32 interface_transitionPeriod)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interface_timestamp(interface_timestamp),
    m_interface_newState(interface_newState),
    m_interface_transitionPeriod(interface_transitionPeriod)
{
}

Deferral^ LampStateTransitionLampStateCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateTransitionLampStateCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateTransitionLampStateCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateTransitionLampStateCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateTransitionLampStateCalledEventArgs::InvokeCompleteHandler()
{
    m_tce.set(m_result);
}

LampStateApplyPulseEffectCalledEventArgs::LampStateApplyPulseEffectCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Windows::Foundation::Collections::IMapView<Platform::String^,Platform::Object^>^ interface_fromState,
    _In_ Windows::Foundation::Collections::IMapView<Platform::String^,Platform::Object^>^ interface_toState,
    _In_ uint32 interface_period,
    _In_ uint32 interface_duration,
    _In_ uint32 interface_numPulses,
    _In_ uint64 interface_timestamp)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interface_fromState(interface_fromState),
    m_interface_toState(interface_toState),
    m_interface_period(interface_period),
    m_interface_duration(interface_duration),
    m_interface_numPulses(interface_numPulses),
    m_interface_timestamp(interface_timestamp)
{
}

Deferral^ LampStateApplyPulseEffectCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateApplyPulseEffectCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateApplyPulseEffectCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateApplyPulseEffectCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateApplyPulseEffectCalledEventArgs::InvokeCompleteHandler()
{
    m_tce.set(m_result);
}

// Readable Properties
LampStateGetVersionRequestedEventArgs::LampStateGetVersionRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
}

Deferral^ LampStateGetVersionRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateGetVersionRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateGetVersionRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetVersionRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetVersionRequestedEventArgs::InvokeCompleteHandler()
{
    m_tce.set(m_result);
}

LampStateGetOnOffRequestedEventArgs::LampStateGetOnOffRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
}

Deferral^ LampStateGetOnOffRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateGetOnOffRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateGetOnOffRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetOnOffRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetOnOffRequestedEventArgs::InvokeCompleteHandler()
{
    m_tce.set(m_result);
}

LampStateGetHueRequestedEventArgs::LampStateGetHueRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
}

Deferral^ LampStateGetHueRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateGetHueRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateGetHueRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetHueRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetHueRequestedEventArgs::InvokeCompleteHandler()
{
    m_tce.set(m_result);
}

LampStateGetSaturationRequestedEventArgs::LampStateGetSaturationRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
}

Deferral^ LampStateGetSaturationRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateGetSaturationRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateGetSaturationRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetSaturationRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetSaturationRequestedEventArgs::InvokeCompleteHandler()
{
    m_tce.set(m_result);
}

LampStateGetColorTempRequestedEventArgs::LampStateGetColorTempRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
}

Deferral^ LampStateGetColorTempRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateGetColorTempRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateGetColorTempRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetColorTempRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetColorTempRequestedEventArgs::InvokeCompleteHandler()
{
    m_tce.set(m_result);
}

LampStateGetBrightnessRequestedEventArgs::LampStateGetBrightnessRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
}

Deferral^ LampStateGetBrightnessRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateGetBrightnessRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateGetBrightnessRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetBrightnessRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateGetBrightnessRequestedEventArgs::InvokeCompleteHandler()
{
    m_tce.set(m_result);
}

// Writable Properties
LampStateSetOnOffRequestedEventArgs::LampStateSetOnOffRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ bool value)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_value(value)
{
    // If no event listener is registered by the app, the handler is not implemented.
    // This will result in InvokeCompleteHandler throwing an exception unless some
    // event listener actually runs and sets the result status.
    m_resultStatus = ER_NOT_IMPLEMENTED;
}

Deferral^ LampStateSetOnOffRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateSetOnOffRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateSetOnOffRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateSetOnOffRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateSetOnOffRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_resultStatus == ER_NOT_IMPLEMENTED)
    {
        m_tce.set_exception(std::make_exception_ptr(std::runtime_error("no listeners registered for SetNameRequested")));
    }
    else
    {
        m_tce.set(m_resultStatus);
    }
}

LampStateSetHueRequestedEventArgs::LampStateSetHueRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ uint32 value)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_value(value)
{
    // If no event listener is registered by the app, the handler is not implemented.
    // This will result in InvokeCompleteHandler throwing an exception unless some
    // event listener actually runs and sets the result status.
    m_resultStatus = ER_NOT_IMPLEMENTED;
}

Deferral^ LampStateSetHueRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateSetHueRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateSetHueRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateSetHueRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateSetHueRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_resultStatus == ER_NOT_IMPLEMENTED)
    {
        m_tce.set_exception(std::make_exception_ptr(std::runtime_error("no listeners registered for SetNameRequested")));
    }
    else
    {
        m_tce.set(m_resultStatus);
    }
}

LampStateSetSaturationRequestedEventArgs::LampStateSetSaturationRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ uint32 value)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_value(value)
{
    // If no event listener is registered by the app, the handler is not implemented.
    // This will result in InvokeCompleteHandler throwing an exception unless some
    // event listener actually runs and sets the result status.
    m_resultStatus = ER_NOT_IMPLEMENTED;
}

Deferral^ LampStateSetSaturationRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateSetSaturationRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateSetSaturationRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateSetSaturationRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateSetSaturationRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_resultStatus == ER_NOT_IMPLEMENTED)
    {
        m_tce.set_exception(std::make_exception_ptr(std::runtime_error("no listeners registered for SetNameRequested")));
    }
    else
    {
        m_tce.set(m_resultStatus);
    }
}

LampStateSetColorTempRequestedEventArgs::LampStateSetColorTempRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ uint32 value)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_value(value)
{
    // If no event listener is registered by the app, the handler is not implemented.
    // This will result in InvokeCompleteHandler throwing an exception unless some
    // event listener actually runs and sets the result status.
    m_resultStatus = ER_NOT_IMPLEMENTED;
}

Deferral^ LampStateSetColorTempRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateSetColorTempRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateSetColorTempRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateSetColorTempRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateSetColorTempRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_resultStatus == ER_NOT_IMPLEMENTED)
    {
        m_tce.set_exception(std::make_exception_ptr(std::runtime_error("no listeners registered for SetNameRequested")));
    }
    else
    {
        m_tce.set(m_resultStatus);
    }
}

LampStateSetBrightnessRequestedEventArgs::LampStateSetBrightnessRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ uint32 value)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_value(value)
{
    // If no event listener is registered by the app, the handler is not implemented.
    // This will result in InvokeCompleteHandler throwing an exception unless some
    // event listener actually runs and sets the result status.
    m_resultStatus = ER_NOT_IMPLEMENTED;
}

Deferral^ LampStateSetBrightnessRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampStateSetBrightnessRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampStateSetBrightnessRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateSetBrightnessRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampStateSetBrightnessRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_resultStatus == ER_NOT_IMPLEMENTED)
    {
        m_tce.set_exception(std::make_exception_ptr(std::runtime_error("no listeners registered for SetNameRequested")));
    }
    else
    {
        m_tce.set(m_resultStatus);
    }
}

} } } 
